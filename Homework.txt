数据结构任务3
1.
/**
 *子任务名：设计入栈、出栈及栈中元素个数3个函数
 *姓名：蔡础隆  班级：5班  学号：2020012271  日期：2021/10/01
 */
/* 初始化栈 */
S *initStack(S *s)
{
    s = (S *)malloc(sizeof(S));
    if (!s)
    {
        fprintf(stderr, "OVERFLOW\n");
        exit(EXIT_FAILURE);
    }
    s->top = 50;
    return s;
}
/* 入栈 */
void push(S *s, char e)
{
    if (s->top == 0)
    {
        fprintf(stderr, "The Stack is full\n");
        exit(EXIT_FAILURE);
    }
    s->top--;
    s->arr[s->top] = e;
}
/* 出栈 */
void pop(S *s, char e)
{
    if (s->top == 50)
    {
        fprintf(stderr, "The Stack is null\n");
        exit(EXIT_FAILURE);
    }
    e = s->arr[s->top++];
}
/* 栈中元素个数 */
int lenStack(S *s)
{
    int len = 0;
    while (s->top != 50)
    {
        len++;
        s->top++;
    }
    return len;
}
2.
/**
 *子任务名：编写入队和出队的算法
 *姓名：蔡础隆  班级：5班  学号：2020012271  日期：2021/10/01
 */
/* 入队 */
void enQueue(Q *q, int e)
{
    if (q->rear == q->front && q->count == 1)
    {
        fprintf(stderr, "The queue is full\n");
        exit(EXIT_FAILURE);
    }
    q->data[q->rear] = e;              // 插入队尾
    q->rear = (q->rear + 1) % MAXSIZE; // 尾部指针后移，如果到最后则转到头部
    if (q->rear == q->front)
        q->count = 1;
}
/* 出队 */
void deQueue(Q *q, int *e)
{
    if (q->front == q->rear && q->count == 0)
    {
        fprintf(stderr, "The queue is null\n");
        exit(EXIT_FAILURE);
    }
    *e = q->data[q->front];              // 返回队头元素
    q->front = (q->front + 1) % MAXSIZE; // 队头指针后移，如到最后转到头部
    if (q->front == q->rear)
        q->count = 0;
}
3.
/**
 *子任务名：完成下面3个函数
 *姓名：蔡础隆  班级：5班  学号：2020012271  日期：2021/10/01
 */
/* 队尾插入元素 */
void EnQ(LQ *q, char x)
{
    Node *s = (Node *)malloc(sizeof(Node));
    if (!q)
    {
        fprintf(stderr, "OVERFLOW\n");
        exit(EXIT_FAILURE);
    }
    s->data = x;
    s->next = NULL;
    q->r->next = s; // 原来队尾的 next 指向新的元素
    q->r = s;       // 将新元素变为队尾
}
/* 队头元素出队 */
int DeQ(LQ *q, char *x)
{
    Node *p;
    if (q->f == q->r)
        return 0;
    p = q->f->next; // p指向队头元素
    *x = p->data;
    q->f->next = p->next; // 头结点的后继指向队头的下一个元素
    if (q->r == p)
        q->r = q->f; // 队尾直接指向头结点将其出队
    free(p);
    return 1;
}
/* 遍历 */
void vist(LQ *q)
{
    Node *p;
    p = q->f->next;
    while (p)
    {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}


数据结构任务2
1.
/**
 *子任务名：线性表去重
 *姓名：蔡础隆  班级：5班  学号：2020012271  日期：2021/9/16
 */
/* 去重 */
void removeRepetiton(LinkList h)
{
    if (NULL == h)
        fprintf(stderr, "Failed\n");
    else
    {
        Node *p = h->next;
        while (h)
        {
            p = h->next;
            while (p)
            {
                if (h->data == p->data)
                {
                    h->next = p->next;
                }
                p = p->next;
            }
            h = h->next;
        }
    }
}
 2.
/**
 *子任务名：从单链表A中删除自第i个元素起的共len个元素，然后将单链表A插入到单链表B的第j个元素之前
 *姓名：蔡础隆  班级：5班  学号：2020012271  日期：2021/9/16
 */
int lenList(LinkList h)
{
    if (NULL == h || NULL == h->next)
        return 0;
    int lengh = 0;
    while (h->next)
    {
        h = h->next;
        lengh++;
    }
    return lengh;
}

void DelList(LinkList h, int position, int len)
{
    if (position > lenList(h) || position < 1 || len > lenList(h) || len < 0 || NULL == h)
        fprintf(stderr, "Failed\n");
    else
    {
        while (--position)
            h = h->next;
        Node *p = h;
        for (int i = 0; i < len + 1; i++)
            h = h->next;
        p->next = h;
    }
}

void insertAToB(LinkList ha, LinkList hb, int position)
{
    if (position > lenList(hb) || position < 0 || NULL == ha || NULL == hb)
        fprintf(stderr, "Failed\n");
    else
    {
        while (position-- > 0)
            hb = hb->next;
        Node *p = hb->next;
        hb->next = ha->next;
        while (hb->next)
            hb = hb->next;
        hb->next = p;
    }
}
3.
/**
 *子任务名：判断链表所有字符是否中心对称
 *姓名：蔡础隆  班级：5班  学号：2020012271  日期：2021/9/16
 */
void isSymmetric(LinkList h)
{
    if (NULL == h)
        fprintf(stderr, "Failed\n");
    else
    {
        LinkList p = h->next, q = h;
        int len = lenList(h);

        for (int i = 0; i < len / 2; i++)
        {
            for (int j = i; j < len; j++)
                h = h->next;
            if (h->data != p->data)
            {
                printf("isNotSymmetric\n");
                return;
            }
            p = p->next;
            h = q;
        }
        printf("isSymmetric\n");
    }
}


数据结构任务1
1.设运行次数为 i，
根据 while 循环的条件和里面的代码有
 2^(i+1) = 2^((log2 n)-1)
化简得 i = (log2 n) - 2
所以时间复杂度为 T(n) = O(log n)
变量 count 的值为 (log2 n) - 2
2.
int Fibonacci(int k, int m)
{
    int j = 0, sum = 0;
    int *arr = calloc(m + 1, sizeof(int));
    for (int i = 0; i < k; i++)
    {
        if (i < k - 1)
            arr[j++] = 0;
        if (i == k - 1)
            arr[j++] = 1;
    }//k
    for (int n = 0; n < m - k + 1; n++)
    {
        for (int i = j; i > j - k; i--)
        {
            arr[j] += arr[i - 1];
        }//k
        j++;
    }//(m-k+1) * k
    return arr[j - 2];
}
k * (m + 2) - k ^ 2
T(n) = O(n^2)
3.
可以看出函数的算法为二分查找
第一步进行了一次对比可以写成 f(n) = 1 + f(n/ 2)；
然后将brr[n]一分为二，根据有序数组的特性，通过比较 m 与标的元素的大小，知道了x落入其中一个子数组brr[n/2]；重复以上步骤，可以得到
f(n) =  1 + f(n / 2)
     =  1 + （1 + f(n / 4)）
     =  2 + f(n / 4)
f(n) = k + f(n / (2^k))
如果以上步骤重复了k次之后，数组只余一个元素无法再分，计算结束。此时
f(N) = k + f(1) = k + 1
N / (2^k) = 1
于是
n = 2^k
k = log2(N)
T(n) = O(log n)
